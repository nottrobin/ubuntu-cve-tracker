;;; cve-mode.el --- major mode for editing CVE files         -*- lexical-binding: t; -*-

;; Copyright (c) 2018 Alex Murray

;; Author: Alex Murray <alex.murray@canonical.com>
;; Maintainer: Alex Murray <alex.murray@canonical.com>
;; URL: https://launchpad.net/ubuntu-cve-tracker
;; Version: 0.1
;; Package-Requires: ((emacs "24.4"))

;; This file is not part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;;; Setup

;; (require 'cve-mode)

;;; Code:
(require 'bug-reference)
(require 'seq)

;;; Forward declaration of optional dependencies
(declare-function flycheck-define-checker "ext:flycheck.el")

(defconst cve-mode-base-path
  (file-name-directory
   (file-truename
    (expand-file-name
     (or load-file-name buffer-file-name))))
  "The directory where cve-mode.el resides (should be $UCT/scripts/).")

(defgroup cve-mode nil
  "Major mode for editing Ubuntu CVE Tracker CVE files."
  :group 'languages)

(defcustom cve-mode-fill-column 76
  "`fill-column' for `cve-mode'."
  :group 'cve-mode
  :type 'integer)

(defcustom cve-mode-default-notes-user user-login-name
  "The default user to use for new Notes: entries."
  :group 'cve-mode
  :type '(choice (const nil) string))

(defcustom cve-mode-prefix-notes-lines 'first
  "Whether to prefix only the 'first or 'all lines of Notes with user>.
When set to first, following lines will be indented by an extra space."
  :type '(choice (const first) (const all)))

(defvar cve-mode-keywords '("Candidate" "PublicDate" "PublicDateAtUSN" "CRD" "References" "Description" "Ubuntu-Description" "Notes" "Bugs" "Priority" "Discovered-by" "Assigned-to" "Mitigation"))

(defvar cve-mode-all-releases '("devel" "upstream" "product" "warty" "hoary" "breezy" "dapper" "edgy" "feisty" "gutsy" "hardy" "intrepid" "jaunty" "karmic" "lucid" "maverick" "natty" "oneiric" "precise" "precise/esm" "quantal" "raring" "saucy" "trusty" "trusty/esm" "utopic" "vivid" "vivid/stable-phone-overlay" "vivid/ubuntu-core" "wily" "xenial" "yakkety" "zesty" "artful" "bionic" "cosmic" "disco"))

(defvar cve-mode-releases '("precise/esm" "trusty/esm" "xenial" "bionic" "disco" "devel"))

(defvar cve-mode-devel-release "eoan")

(defvar cve-mode-statuses '("needs-triage" "needed" "deferred" "pending" "released" "ignored" "not-affected" "DNE"))

(defvar cve-mode-priorities '("negligible" "low" "medium" "high" "critical"))

(defvar cve-mode-tags '("apparmor" "fortify-source" "hardlink-restriction" "heap-protector" "not-ue" "pie" "stack-protector" "symlink-restriction" "universe-binary"))

(defvar cve-mode-cve-id-regexp "\\(CVE-[[:digit:]]\\{4\\}-[[:digit:]]\\{4,\\}\\)")

(defvar cve-mode-date-time-regexp (concat
                                   "\\(\\([[:digit:]]\\{4\\}-[[:digit:]]\\{2\\}-[[:digit:]]\\{2\\}\\)"
                                   "\\( \\([[:digit:]]\\{2\\}:[[:digit:]]\\{2\\}:[[:digit:]]\\{2\\}"
                                   "\\( [A-Z]+\\)?\\)\\)?\\|unknown\\)$"))

(defvar cve-mode-note-regexp "^\\s-+\\([[:alnum:]]+\\)\\(>\\)\\(.*\\)")

(defvar cve-mode-package-name-regexp "[a-z0-9][a-z0-9+.-]+")

(defvar cve-mode-patch-types '("upstream" "backport" "vendor" "other" "break-fix"))

(defvar cve-mode-patch-types-regexp (concat "^ \\(" (regexp-opt cve-mode-patch-types) "\\):"))

(defvar cve-mode-patches-regexp (concat "^\\(\\(Patches\\)_\\(" cve-mode-package-name-regexp "\\)\\):"))

(defvar cve-mode-tags-regexp (concat "\\(\\(Tags\\)_\\(" cve-mode-package-name-regexp "\\)\\): \\(\\(" (regexp-opt cve-mode-tags) "\\) *\\)+"))

(defvar cve-mode-keywords-regexp (concat "^\\(" (regexp-opt cve-mode-keywords) "\\):"))

(defvar cve-mode-releases-regexp (concat "^\\(" (regexp-opt cve-mode-all-releases) "\\)" "_"
                                         "\\(" cve-mode-package-name-regexp "\\):"))

(defvar cve-mode-priority-regexp (concat "^Priority: \\(" (regexp-opt cve-mode-priorities) "\\)$"))

(defvar cve-mode-assigned-to-regexp (concat "^Assigned-to: \\([A-Za-z ]+\\)"))

(defvar cve-mode-priority-package-regexp
  (concat "^\\(\\(Priority\\)_\\(" cve-mode-package-name-regexp "\\)\\): "
          "\\(" (regexp-opt cve-mode-priorities) "\\)"))

(defvar cve-mode-priority-package-release-regexp
  (concat "^\\(Priority\\)_\\(" cve-mode-package-name-regexp "\\)"
          "\\(_\\(" (regexp-opt cve-mode-releases) "\\)\\)?: "
          "\\(" (regexp-opt cve-mode-priorities) "\\)"))

(defvar cve-mode-description-regexp (concat "^ \\(.*\\)$"))

(defvar cve-mode-font-lock-defaults
  `(((,cve-mode-keywords-regexp
      (1 font-lock-keyword-face))
     (,cve-mode-patch-types-regexp
      (1 font-lock-keyword-face))
     (,(concat "^Candidate:\\s-*\\(" cve-mode-cve-id-regexp "\\)")
      (1 font-lock-function-name-face))
     ,`(,cve-mode-releases-regexp
        (1 font-lock-constant-face)
        (2 font-lock-variable-name-face)
        ;; match first but then reset position back to end of releases so
        ;; we can continue to match status keywords
        ("(.*)"
         nil (re-search-backward cve-mode-releases-regexp)
         (0 font-lock-doc-face t))
        ("\\<DNE\\>" nil nil (0 font-lock-comment-face t))
        ("\\<not-affected\\>" nil nil (0 font-lock-comment-face t))
        ("\\<ignored\\>" nil nil (0 font-lock-comment-face t))
        ("\\<needed\\>" nil nil (0 font-lock-warning-face t))
        ("\\<needs-triage\\>" nil nil (0 font-lock-warning-face t))
        ("\\<deferred\\>" nil nil (0 font-lock-builtin-face t))
        ("\\<pending\\>" nil nil (0 font-lock-constant-face t))
        ("\\<released\\>" nil nil (0 font-lock-keyword-face t)))
     ("^Priority: "
      ("\\<negligible\\>" nil nil (0 font-lock-comment-face t))
      ("\\<low\\>" nil nil (0 font-lock-comment-face t))
      ("\\<medium\\>" nil nil (0 font-lock-variable-name-face t))
      ("\\<high\\>" nil nil (0 font-lock-warning-face t))
      ("\\<critical\\>" nil nil (0 font-lock-warning-face t)))
     (,cve-mode-assigned-to-regexp
      (1 font-lock-type-face))
     (,cve-mode-note-regexp
      (1 font-lock-type-face)
      (2 font-lock-builtin-face)
      (3 font-lock-doc-face))
     (,cve-mode-patches-regexp
      (2 font-lock-constant-face)
      (3 font-lock-variable-name-face))
     (,cve-mode-priority-package-regexp
      (2 font-lock-keyword-face)
      (3 font-lock-variable-name-face)
      (4 font-lock-type-face))
     (,cve-mode-priority-package-release-regexp
      (1 font-lock-keyword-face)
      (2 font-lock-variable-name-face)
      (4 font-lock-constant-face)
      (5 font-lock-type-face))
     (,cve-mode-tags-regexp
      (2 font-lock-constant-face)
      (3 font-lock-variable-name-face)
      (5 font-lock-keyword-face))
     (":>" . 'font-lock-builtin-face)
     ;; CVE Ids
     (,cve-mode-cve-id-regexp
      (1 font-lock-variable-name-face))
     (,cve-mode-date-time-regexp
      (0 font-lock-variable-name-face)))))

(defvar cve-mode-syntax-table
  (let ((table (make-syntax-table)))
    ;; add / and _ as symbol characters
    (modify-syntax-entry ?/ "/" table)
    (modify-syntax-entry ?_ "/" table)
    ;; # is comment start
    (modify-syntax-entry ?# "<" table)
    ;; newline finishes comment line
    (modify-syntax-entry ?\n ">" table)
    table))

(defun cve-mode-completion-at-point ()
  "`completion-at-point' function for cve-mode."
  (let ((bounds (bounds-of-thing-at-point 'symbol)))
    (list (car bounds) ; start
          (cdr bounds) ; end
          (append cve-mode-keywords cve-mode-releases cve-mode-statuses cve-mode-priorities cve-mode-tags)
          :company-docsig #'identity)))

(defun cve-mode-indent-line ()
  "Indent current line in cve-mode."
  (interactive)
  (if (bolp)
      (cve-mode--indent-line)
    (save-excursion
      (cve-mode--indent-line))))

(defun cve-mode--note-user ()
  "Get the user who authored the current note."
  (unless (string= (cve-mode--current-block) "Notes")
    (error "This is not a Notes block"))
  (save-excursion
    (let ((user nil))
      (beginning-of-line)
      (while (not (or (and (looking-at cve-mode-note-regexp)
                           (re-search-forward cve-mode-note-regexp)
                           (setq user (match-string 1)))
                      (looking-at "^[A-Z].*")))
        (forward-line -1))
      user)))

(defun cve-mode--indent-line ()
  "Indent current line in cve-mode."
  (let ((block (cve-mode--current-block)))
    (beginning-of-line)
    (cond
     ((or (looking-at cve-mode-keywords-regexp)
          (looking-at cve-mode-releases-regexp)
          (looking-at cve-mode-patches-regexp))
      ;; headings etc indent to 0
      (indent-line-to 0))
     ((or (looking-at cve-mode-patch-types-regexp))
      (indent-line-to 1))
     ((and (string= block "Notes")
           (not (looking-at cve-mode-note-regexp))
           (cve-mode--note-user))
      (indent-line-to 2))
     ;; indent bracketed / parenthesised descriptions
     ((and (string= block "Description")
           (> (car (syntax-ppss)) 0))
      (indent-line-to 2))
     (t
      (indent-line-to 1)))))

(defun cve-mode-set-priority (&optional priority)
  "Set the current CVE's PRIORITY (prompt if none specified)."
  (interactive
   (list (completing-read "Priority: " cve-mode-priorities)))
  (save-excursion
    (save-restriction
      (goto-char (point-min))
      (if (re-search-forward cve-mode-priority-regexp nil t)
          (replace-match priority nil t nil 1)
        (error "Unable to find Priority field in CVE")))))

(defun cve-mode-set-assigned-to (&optional assignee)
  "Assign the current CVE to ASSIGNEE (prompt if none specified)."
  (interactive "sAssignee: ")
  (save-excursion
    (save-restriction
      (goto-char (point-min))
      (if (re-search-forward "^Assigned-to:\\(.*\\)$" nil t)
          ;; ensure a space after the colon
          (replace-match (concat " " assignee) nil t nil 1)
        (error "Unable to find Assigned-to field in CVE")))))

(defun cve-mode-add-note (&optional user note)
  "Add a NOTE by USER to the current CVE (prompt if none specified)."
  (interactive (list (read-string "User: " cve-mode-default-notes-user)
                     (read-string "Note: ")))
  (save-excursion
    (save-restriction
      (goto-char (point-min))
      (if (null (re-search-forward "^Notes:" nil t))
          (error "Unable to find Notes field of CVE")
        ;; now go to the next heading in the CVE so we append to the
        ;; existing Notes
        (re-search-forward "^[A-Z]")
        (beginning-of-line)
        ;; format note across lines
        (let ((beg (point)))
          ;; add a newline so we can push the next heading down one line so
          ;; it doesn't inadvertently get appended to the new note
          (insert "\n")
          (cve-mode--replace-note-in-region beg beg user note)
          (goto-char beg))))))

(defvar cve-mode--source-packages
  (split-string
   (shell-command-to-string "grep Package: /var/lib/apt/lists/*Sources | awk '{print $2}' | sort | uniq")))

(defvar cve-mode--packages-releases nil)

(defun cve-mode--package-releases (package)
  "Get the list of releases where PACKAGE exists.
Queries umt for PACKAGE as well as looking in overlay files."
  (let ((status (assoc-string package cve-mode--packages-releases)))
    (if (not (null status))
        (cdr status)
      (let ((releases nil))
        (with-temp-buffer
          (shell-command (format "umt search \"%s\"" package) (current-buffer))
          (goto-char (point-min))
          (while (re-search-forward (concat "^\\([a-z]\+\\): .*, Pocket:.*, Component: .*$") nil t)
            (let ((release (match-string 1)))
              (push release releases))))
        ;; look for overlay files for specific overlay releases
        (dolist (release cve-mode-releases)
          (when (string-match-p "/" release)
            (let ((overlay-filename (concat
                                     (replace-regexp-in-string "/" "-" release)
                                     "-supported.txt")))
              ;; also get for precise-esm specifically
              (with-temp-buffer
                (insert-file-contents
                 (expand-file-name overlay-filename
                                   (file-name-directory
                                    (directory-file-name
                                     cve-mode-base-path))))
                (when (re-search-forward (concat "^" package "$") nil t)
                  (push release releases))))))
        (add-to-list 'cve-mode--packages-releases `(,package . ,releases))
        (cve-mode--package-releases package)))))

(defun cve-mode-insert-package (package)
  "Add PACKAGE as affected to this CVE.
Calls out to active_edit to do the heavy lifting so that
boilerplate entries are handled automatically."
  (interactive
   (list (completing-read "Package: " cve-mode--source-packages)))
  (let ((args (list "-c" (file-name-base) "-p" package "-y"))
        (output (get-buffer-create "*active_edit*")))
    ;; need to tell active_edit is embargoed if file is already in
    ;; embargoed tree
    (when (string-match-p "embargoed/" (buffer-file-name))
      (push "-e" args))
    (when (buffer-modified-p)
      (if (y-or-n-p "Buffer is modified.  Do you want to save it first? ")
          (save-buffer)
        (user-error "Unable to proceed with modified buffer")))
    ;; call call-process via apply so we can pass the list of arguments for
    ;; active_edit as a list itself rather than as individual arguments
    (apply #'call-process
           (expand-file-name
            "active_edit"
            cve-mode-base-path)
           nil output t args)
    (let ((revert-without-query t))
      (revert-buffer))))

(defun cve-mode--cve-packages ()
  "Return the list of packages for the current CVE."
  (let ((packages))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward cve-mode-patches-regexp nil t)
        (push (substring-no-properties (match-string 3)) packages)))
    (nreverse packages)))

(defun cve-mode--download-patch (type url filename)
  "Download patch of TYPE from URL to FILENAME."
  (cond ((string= type "upstream")
         (cond ((string-match-p "^https://github.com/.*/commit/[0-9a-f]+$" url)
                (url-copy-file (concat url ".patch") filename))
               (t (error "Unable to download %s patches like %s" type url))))
        (t (error "Unable to download %s patches" type))))

(defun cve-mode-download-patches (directory package)
  "Download the current CVEs patches for PACKAGE to DIRECTORY."
  (interactive (list (read-directory-name "Target: ")
                     (completing-read "Package: " (cve-mode--cve-packages))))
  (let ((beg nil)
        (end nil)
        (n 1))
    (save-excursion
      (goto-char (point-min))
      (while (and (null beg) (null end)
                  (re-search-forward cve-mode-patches-regexp nil t))
        (when (string= (substring-no-properties (match-string 3)) package)
          (setq beg (point))
          (re-search-forward cve-mode-releases-regexp)
          (forward-line -1)
          (setq end (line-end-position))
          (goto-char beg)
          (while (re-search-forward cve-mode-patch-types-regexp end t)
            (cve-mode--download-patch
             (match-string 1)
             (string-trim
              (buffer-substring-no-properties (point) (line-end-position)))
             (expand-file-name
              (format (concat (file-name-base) "-%d.patch") n)
              directory))
            (incf n)))))))

(defun cve-mode--cve-urls ()
  "Returns the list of URLs listed in the current CVE."
  (save-excursion
    (save-restriction
      (goto-char (point-min))
      (let ((urls))
        (while (re-search-forward "\\(https?://[^[:space:]\n]+\\)" nil t)
          (message (match-string 1))
          (push (match-string 1) urls))
        (nreverse urls)))))

(defun cve-mode-browse-url (&optional url)
  "Prompt user to browse for one of the URLs referenced in the CVE."
  (interactive (list (completing-read "URL: " (cve-mode--cve-urls))))
  (browse-url url))

(defun cve-mode--current-block ()
  "Get the name of the current block."
  (save-excursion
    (let ((block-regexp "^\\([A-Za-z0-9_-]+\\):\\s-*$"))
      (beginning-of-line)
      ;; if not already at a block heading, find the one we are in
      (unless (looking-at block-regexp)
        (re-search-backward block-regexp))
      (substring-no-properties (match-string 1)))))

(defun cve-mode--narrow-to-block ()
  "Narrow to the current block."
  ;; find current block heading - blocks are delimited by starting at start
  ;; of line
  (save-excursion
    (let ((block-regexp "^\\([A-Za-z0-9/_-]+\\):"))
      (beginning-of-line)
      ;; if not already at a block heading, find the one we are in
      (unless (looking-at block-regexp)
        (re-search-backward block-regexp))
      ;; get the line after this as the start of the current block
      (let* ((beg (progn (forward-line) (line-beginning-position)))
             (end beg))
        (when (re-search-forward block-regexp nil t)
          ;; use line end of line above next heading as end of region
          (forward-line -1)
          (setq end (line-end-position)))
        ;; always narrow to something so we don't overfill
        (narrow-to-region beg end)))))

(defun cve-mode--replace-note-in-region (beg end user note &optional justify region)
  "Replace region from BEG to END with NOTE from USER and fill for JUSTIFY and REGION."
  (save-excursion
    (save-restriction
      ;; fill previous note - erase it then insert it
      ;; and fill it
      (narrow-to-region beg end)
      (delete-region beg end)
      (goto-char beg)
      (when (eq cve-mode-prefix-notes-lines 'first)
        (insert (concat " " user "> ")))
      (insert note)
      (let ((fill-paragraph-function nil)
            (fill-column cve-mode-fill-column)
            (fill-prefix (if (eq cve-mode-prefix-notes-lines 'all) (concat " " user "> ")))
            (adaptive-fill-function #'(lambda () "  ")))
        (indent-region beg (point))
        (fill-paragraph justify region)))))

(defun cve-mode--fill-notes (&optional justify region)
  "Fill the current visible buffer as Notes with JUSTIFY and REGION."
  ;; notes should always have user> as a prefix somewhere and could have
  ;; multiple ones - process one-line at a time
  (save-excursion
    (save-restriction
      (goto-char (point-min))
      (let ((beg nil)
            (end nil)
            (user nil)
            (note nil))
        (while (< (point) (point-max))
          ;; user> foo
          (cond ((looking-at cve-mode-note-regexp)
                 (re-search-forward cve-mode-note-regexp)
                 ;; if no user yet, this is the first line so use it
                 (if (not user)
                     (setq beg (match-beginning 0)
                           end (match-end 0)
                           user (substring-no-properties (match-string 1))
                           note (substring-no-properties (match-string 3)))
                   (if (string= user (substring-no-properties (match-string 1)))
                       ;; is same user - concatenate note
                       (setq note (concat note " " (substring-no-properties
                                                    (match-string 3)))
                             end (match-end 0))
                     (save-match-data
                       (cve-mode--replace-note-in-region beg end user note
                                                         justify region))
                     (setq beg (match-beginning 0)
                           end (match-end 0)
                           user (substring-no-properties (match-string 1))
                           note (substring-no-properties (match-string 3))))))
                (t
                 (setq note (concat note " "
                                    (string-trim
                                     (buffer-substring-no-properties
                                      (point) (line-end-position))))
                       end (line-end-position))))
          ;; always try and advance to next line
          (forward-line))
        ;; have to now fill the last note
        (when (and beg end user note)
          (cve-mode--replace-note-in-region beg end user note justify region))))))

(defun cve-mode-fill-paragraph (&optional justify region)
  "Fill paragraph and JUSTIFY with REGION.
This behaves as `fill-paragraph' except that filling does not
cross boundaries of block literals."
  (interactive "*P")
  (save-excursion
    (save-restriction
      (let ((block (cve-mode--current-block)))
        (cve-mode--narrow-to-block)
        (cond ((string= block "Notes")
               (cve-mode--fill-notes justify region))
              (t
               ;; TODO - special case break-fix / patches etc so we don't
               ;; break too many lines
               (let ((fill-paragraph-function nil)
                     (fill-column cve-mode-fill-column)
                     (fill-prefix " "))
                 (indent-region (point-min) (point-max))
                 (fill-paragraph justify region))))))))

(defun cve-mode-auto-fill-function ()
  "Auto fill for cve-mode."
  (save-excursion
    (beginning-of-line)
    (if (re-search-forward cve-mode-note-regexp (line-end-position) t)
        (let ((fill-prefix (if (eq cve-mode-prefix-notes-lines 'all)
                               (concat " " (substring-no-properties (match-string 1))
                                       "> ")
                             "  ")))
          (do-auto-fill))
      (let ((fill-prefix " "))
        (do-auto-fill)))))

(defvar cve-mode-map
  (let ((map (make-sparse-keymap)))
    ;; prefix actions with C-c C-v C-mnemonic
    (define-key map (kbd "C-c C-v C-a") #'cve-mode-set-assigned-to)
    (define-key map (kbd "C-c C-v C-i") #'cve-mode-insert-package)
    (define-key map (kbd "C-c C-v C-n") #'cve-mode-add-note)
    (define-key map (kbd "C-c C-v C-p") #'cve-mode-set-priority)
    (define-key map (kbd "C-c C-v C-d") #'cve-mode-download-patches)
    (define-key map (kbd "C-c C-v C-b") #'cve-mode-browse-url)
    map)
  "Keymap for `cve-mode'.")

;;;###autoload
(define-derived-mode cve-mode text-mode "CVE"
  "cve-mode is a major mode for editing CVE files."
  :syntax-table cve-mode-syntax-table
  (setq font-lock-defaults cve-mode-font-lock-defaults)
  (setq imenu-generic-expression `(("Headings" ,cve-mode-keywords-regexp 0)
                                   ("Packages" ,cve-mode-patches-regexp 3)))
  (add-to-list 'completion-at-point-functions #'cve-mode-completion-at-point)
  (set (make-local-variable 'comment-start) "#")
  (set (make-local-variable 'comment-end) "")
  ;; only # at start of line should be a comment - so any # which has
  ;; anything before it should be considered a punctuation character ("."
  ;; character class)
  (set (make-local-variable 'syntax-propertize-function)
       (syntax-propertize-rules (".\\(#+\\)" (1 "."))))
  (set (make-local-variable 'indent-tabs-mode) nil)
  (set (make-local-variable 'indent-line-function) #'cve-mode-indent-line)
  (set (make-local-variable 'fill-paragraph-function) #'cve-mode-fill-paragraph)
  (set (make-local-variable 'normal-auto-fill-function) #'cve-mode-auto-fill-function)
  (set (make-local-variable 'compile-command)
       (concat (file-name-as-directory cve-mode-base-path) "check-syntax "
               (if buffer-file-name
                   (shell-quote-argument buffer-file-name))))
  ;; linkify CVEs via bug-reference-mode
  (set (make-local-variable 'bug-reference-url-format) "https://people.canonical.com/~ubuntu-security/cve/%s.html")
  (set (make-local-variable 'bug-reference-bug-regexp) "\\(\\(CVE-[[:digit:]]\\{4\\}-[[:digit:]]\\{4,\\}\\)\\)")
  (bug-reference-mode 1)
  ;; linkify URLs
  (goto-address-mode 1))

(defconst cve-mode--check-syntax-executable
  (concat (file-name-as-directory cve-mode-base-path) "check-syntax"))

;; flycheck integration
;; silence byte-compiler warnings
(eval-when-compile
  (require 'flycheck nil t))
(when (require 'flycheck nil t)
  ;; no need to be able to override this
  (defconst flycheck-cve-executable
    cve-mode--check-syntax-executable)

  (flycheck-define-checker cve
    "A checker using check-syntax. "
    :command ("check-syntax" source)
    :error-patterns ((warning line-start "WARNING: " (file-name) ": " line ": " (message) line-end)
                     (error line-start (file-name) ": " line ": " (message) line-end))
    :modes cve-mode)

  (add-to-list 'flycheck-checkers 'cve t))

;; flymake integration in place of flycheck
(defvar-local cve-mode--flymake-proc nil)

(defun cve-mode-flymake (report-fn &rest _args)
  "`flymake' backend function for `cve-mode' to report errors via REPORT-FN."
  ;; disable if check-syntax is not available
  (unless (executable-find cve-mode--check-syntax-executable)
    (error "Cannot find check-syntax"))

  ;; kill any existing running instance
  (when (process-live-p cve-mode--flymake-proc)
    (kill-process cve-mode--flymake-proc))

  (let ((source (current-buffer)))
    (save-restriction
      (widen)
      ;; Reset the `cve-mode--flymake-proc' process to a new process
      ;; calling check-syntax.
      (setq
       cve-mode--flymake-proc
       (make-process
	:name "cve-mode-flymake" :noquery t :connection-type 'pipe
	;; Make output go to a temporary buffer.
	;;
	:buffer (generate-new-buffer " *cve-mode-flymake*")
	:command `(,cve-mode--check-syntax-executable "/dev/stdin")
	:sentinel
	(lambda (proc _event)
	  (when (eq 'exit (process-status proc))
	    (unwind-protect
		;; Only proceed if `proc' is the same as
		;; `cve-mode--flymake-proc', which indicates that
		;; `proc' is not an obsolete process.
		;;
		(if (with-current-buffer source (eq proc cve-mode--flymake-proc))
		    (with-current-buffer (process-buffer proc)
		      (goto-char (point-min))
		      ;; Parse the output buffer for diagnostic's
		      ;; messages and locations, collect them in a list
		      ;; of objects, and call `report-fn'.
		      ;;
		      (cl-loop
		       while (search-forward-regexp
			      "^\\(WARNING: \\)?\\(?:.*\\): \\([0-9]+\\): \\(.*\\)$"
			      nil t)
		       for msg = (match-string 3)
		       for (beg . end) = (flymake-diag-region
					  source
					  (string-to-number (match-string 2)))
		       for type = (if (and (match-string 1)
                                           (string= "WARNING: " (match-string 1)))
				      :warning
				    :error)
		       collect (flymake-make-diagnostic source beg end type msg)
		       into diags
		       finally (funcall report-fn diags)))
		  (flymake-log :warning "Canceling obsolete check %s" proc))
	      ;; Cleanup the temporary buffer used to hold the
	      ;; check's output.
	      (kill-buffer (process-buffer proc)))))))
      (process-send-region cve-mode--flymake-proc (point-min) (point-max))
      (process-send-eof cve-mode--flymake-proc))))

;;;###autoload
(defun cve-mode-setup-flymake-backend ()
  "Setuo the `flymake' backend for `cve-mode'."
  (add-hook 'flymake-diagnostic-functions 'cve-mode-flymake nil t))

;;;###autoload
(add-hook 'cve-mode-mode-hook 'cve-mode-setup-flymake-backend)

;;;###autoload
(add-to-list 'auto-mode-alist '("CVE-[[:digit:]]\\{4\\}-[[:digit:]]\\{4,\\}\\'" . cve-mode))
;;;###autoload
(add-to-list 'auto-mode-alist '("00boilerplate.*\\'" . cve-mode))

(provide 'cve-mode)
;;; cve-mode.el ends here
